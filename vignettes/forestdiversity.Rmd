---
title: "forestdiversity"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{forestdiversity}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
fig_width: 6 
fig_height: 6 
---


# Installation of the package

```{r eval=FALSE}
require(devtools)
devtools::install_gitlab('arnaud.guyennon/forestdiversity')
```

```{r setup, include = FALSE}
require(forestdiversity)
DF <- PlotExample
knitr::opts_chunk$set(fig.width=12, fig.height=12)
```

# Diversity/geterogeneity indices
Diversity indices can be calculated using whether species or size classes.

Two different kind of indices can be computed:

1. Hill Numbers
2. Entropy based indices

## Computation of Hill numbers

1. H0 = Number of class (Richness)
2. H1
3. H2

## Computation of entropy based indices

Indices computed are 

1. Number of classes (Richness)
2. Shannon Index
3. Simpson Index

When the variable we used to compute indices is not species, we can also compute the Gini Index.
Here the Gini index is systematically based on proportion of basal area.

## Details on indices

If we $p_i$ the proportion of each class and N the total number of classes:

1. $Nclass = N$ (=H0)

2. $Shannon = \sum_{i=1}^{i=N}( - p_i * log(p_i))$ (=log(H1))

3. $Simpson = \sum_{i=1}^{i=N}(p_i^2)$ (=$\dfrac{1}{H2}$)

The proportion $p_i$ can be calculated on proportion of trees (i.e. the proportion of trees in each species/size class) or as the proportion of basal area (the proportion of total basal area within each species/size class).

## Example

If we want to compute Hill numbers on species and based on density:

```{r, echo = TRUE}
CalcDivIndex(PlotExample, Nvar = 'species', type = 'Density', Out='HillNb')
```

N.B. : if present, the function CalcDivIndex compute the diversity indices for each year/site/src/postThinning/postDisturbance within the dataset. If no weight is present in the dataset, they will be set to 1.

To compute diversity indices based on basal area: 

```{r, echo = TRUE}
CalcDivIndex(PlotExample, Nvar = 'species', type = 'BA', Out='HillNb')
```

To compute entropy based indices on basal area: 

```{r, echo = TRUE}
CalcDivIndex(PlotExample, Nvar = 'species', type = 'BA', Out='Entropy')
```

Both previous calculations can be performed on size rather than on species.
In that case size must be divided into classes using the two parameter:  ClassInter (size of each classes in the same unit as the size variable) and ClassIni (minimum size of  the first class).

```{r, echo = TRUE}
CalcDivIndex(PlotExample, Nvar = 'D_cm', ClassInter=10, ClassIni=5, type = 'Density', Out='HillNb')
```
```{r, echo = TRUE}
CalcDivIndex(PlotExample, Nvar = 'D_cm', ClassInter=10, ClassIni=5, type = 'BA', Out='HillNb')
```

The function used in CalcDivIndex can be used independently.

```
```{r, echo = TRUE}
GiniPop(Size=PlotExample$D_cm, BA=PlotExample$D_cm^2, PLOT=TRUE)
```

# Spatial metrics

We have a dataset named DF with at least trees species, DBH, and location in X / Y:

```{r, echo = FALSE}
print(head(DF))
```
We first need to build a TabDist object using the TabDist function:

```{r, echo = TRUE}
Td <- TabDist(DF, coord=c(0, 80, 0, 80), shape='quadrat', Nselec=10)
```

The shape argument give the shape of the plot ('quadrat' or 'circular'), by default it is 'quadrat'
The coord argument gives the dimension of the plot:

1. if shape=='quadrat' : coord=(xmin, xmax, ymin, ymax) in meters
2. if shape=='circular : coord=radius (in meter)

The Nselec argument give the number of neighboors we should consider for each tree, by default it is 10 and should be left at this value

We can plot the TabDis object 
```{r, echo = TRUE}
plot(Td)
```

We see in the figure the trees that will be used in further calculation (i.e. not to close to the border of the plot) and the border of the plot.
Circles without color will be discarded because they are too close to the border.

Several metrics can then be computed, for each we need to select the number of neighboors that will be used (by default 4) and the type of correction we want to apply to take into account the border effect (by default 'NN1').

## The mingling index

The mingling index (Pommerening et al, 2017) is defined as the "mean heterospecific fraction of plants among the k nearest neighbours of a given plant i."
For each tree in the plot, we compute the fraction of tree in the neighboorhood that belong to the same species as this tree.
We then compute the mean of these fractions.

```{r, echo = TRUE}
Compute_mingling(Td, Nk=4, EdgeCorrection="NN1")
```
For Nk number of neighboors (here 4) we get M the mingling index for k neighboors.
Em is the expected mingling index in case of independent species, and does not depend on the number of neighboors.
Phi is simply $1 - \frac{M}{Em}$ : if phi is 0 then species in the plot are independantly organized, if phi is 1 then species seggregation is maximum, and if phi is -1 then attraction of different species is maximum.

Pommerening et al, 2017 presented their results using 3 neighboors, in IMaestro we use 4 as suggested by Aguirre (2003).

## The Size Differentiation index
The size differentiation index (Pommerening et al, 2017) is the "mean of the ratio of smaller and larger plant sizes u of the k nearest neighbours subtracted from one."
For each tree i, we select the k closest neighboors (by default 4) and compute $T_i=\frac{1}{k}\sum_{j=1}^k \frac{min(u_i, u_j)}{max(u_i, u_j)}$
Here the size u is taken as the DBH.

```{r, echo = TRUE}
Compute_Size_Diff(Td, Nk=4, EdgeCorrection="NN1")
```

As in the mingling index, we also compute the expected size differentiation, which is independent of the number of neighboors, and phi as $1 - \frac{mk}{Em}$.


## The Winkelmass index

Also called the Uniform angle index, "The Winkelmass describes the regularity or irregularity of the spatial distribution of the n trees nearest to a reference tree i" (Hui and Gadow, 2002).
This index is based on the angle between trees and their neighboor and we refer to the paper Hui and Gadow, 2002 to clear explanations.
They give an interpretation to the index :

| Winkelmass    | Category      |
| ------------- |:-------------:|
| 0             | very regular  |
| 0.25          |  regular      |
| 0.5           |  random       |
| 0.75          |  irregular    |
| 1             |very irregular |


```{r, echo = TRUE}
Compute_Winkelmass(Td, Nk=4)
```

## Structural Complexity Index

When height is filled in the dataset (variable 'H_m'), one can compute the structural complexity index (SCI: Zenner & Hibbs 2000).
SCI is defined as "the sum of the surface areas of the [triangulated irregular network] for a stand divided by the ground area covered by all triangles".
We strongly recommend the reading of  Zenner & Hibbs (2000) for a better understanding of this index.
The index ranges from 1 (all trees have the same height) to theoretically infinity, the higher value meaning a higher 3D heterogeneity.

```{r, echo = TRUE}
StructuralComplexityIndex(PlotExample, coord=c(0,80,0,80))
```
# Recovery Metrics (Resilience)

Three resilience metrics can be computed for a selected variable: Time to recover, Degree of recovery after 20 years and the recovery rate.
Here is an example with a virtual simulations for two sites using Salem model:

```{r echo=TRUE}
print(str(VirtualExperiment))
```
The dataset must contain at least these variables: 


1. "year"
2. "D_cm"
3. "species"
4. "postDisturbance"

Variables "site" and "weight" will be filled automatically if they are not in the dataset.
The dataset can be a distribution ( = each line represent a size and a species) or trees ( = each line is a tree with a species and dbh associated).
The variable postDisturbance is crucial as it is the only intel we have on when the perturbation is applied.
The value of postDisturbance (true / false) is specific for each year: each "normal" year, its value is false.
When there is a disturbance, its values are false (same year but before disturbance) and true (same year but after disturbance).

We first need to 'format' Salem outputs:
```{r echo=TRUE}
DF <- format_salem(dataRaw=VirtualExperiment)
print(head(DF))
plot(DF, Nvar='V_m3')
```
This function will mostly compute the heterogeneity index for each year and site.
It creates a new variable called 'preDisturbance': it equals TRUE for every year before the disturbance.
One can plot the object build by format_salem using plot and the name of the variable to be plotted.

The function EventResilience can then be used to compute the recovery metrics.
I will compute an initial state which is meant over all the years classified as preDisturbance==TRUE, that is all the years before the Event.

```{r echo=TRUE}
E <- EventResilience(DF, Nvar='V_m3', RecTime=20)
print(head(E))
```

Some notation explanation: Theta is the recovery rate, TimeRec the time to recovery and DegRec the degree of recovery after X years (the argument RecTime, here 20).
If TimeRec and Theta are -99, it means the system did not reach recovery.
If any value is NA, it means that the metric could not be calculated and data should be inspected.
The function EventResilience also returns the values of the population before disturbance (with the suffix "ini").























